#lang ivy1.8

include failure
include messages
include temporality
include txn
include types

instance server_rpc(txn_t)

include abstract_protocol

global {
    instance net : tcp.net(msg_t)
}

# TODO: the coordinator should be an isolate that simply handles phase 1 of the
# protocol and is composed/mixed into the Node.  (Or perhaps not?)
process coordinator(self: node_id) = {

    # What other transactions depend on our current proposal?
    # This is accumulated from PreAccept and Accept responses.
    instance deps : ordered_set(txn_t)

    var slowpath_accepts : nset
    var fastpath_accepts : nset

    # Committed transactions that have not yet executed (?)
    # TODO: is this actually correct
    var sb: store_buffer

    instance clock : time(self)
    instance sock : net.socket

    instance fd : failure_detector(self)

    common {

        implementation {

            after init(self: node_id) {
                fastpath_accepts(self) := nset.emptyset;
                slowpath_accepts(self) := nset.emptyset;
            }

            # TODO: how can I create a well-formed multi-key txn
            # involving both reads and writes???
            export action client_request(self: node_id, reads: vector[key]) = {
                var now := clock(self).now();

                var qs : vector[query_t];

                var i: index := 0;
                while i < reads.end() {
                    var q: query_t;
                    q.kind := read_kind;
                    q.k := reads.get(i);
                    q.v := option[value].empty;
                    qs := qs.append(q);

                    i := i + 1;
                }
                var txn : txn_t;
                txn.ts := now;
                txn.queries := qs;

                var msg : preaccept_msg_t;
                msg.src := self;
                msg.txn := txn;
                msg.first_proposed_at := now;

                electorate_multicast(self, msg);
                req_in_flight(self) := true; #ghost

                protocol.handle_requested(self, msg);
            }

            #####################################################

            implement preaccept_msg_t.handle(self: node_id, msg: preaccept_msg_t) {
                debug "preaccept_msg_t.handle" with msg=msg;

    
                var deps: vector[txn_t];
                deps := dependencies(msg.txn, sb(self));

                var mc: timestamp;
                var proposed_exec_ts: timestamp;
                mc := max_timestamp(deps);
                if msg.first_proposed_at > mc {
                    proposed_exec_ts := msg.first_proposed_at; 
                } else {
                    proposed_exec_ts.real   := mc.real;
                    proposed_exec_ts.seqid := mc.seqid.next();
                }

                var resp : preaccept_reply_msg_t;
                resp.ok := true; #TODO
                resp.src := self;
                resp.txn := msg.txn;
                resp.txn.ts := proposed_exec_ts;
                resp.deps := filter_timestamps_lt(deps, msg.first_proposed_at);
                resp.first_proposed_at := msg.first_proposed_at;
                resp.witnessed_at := proposed_exec_ts;
                unicast(self, resp, msg.src);

                protocol.handle_preaccepted(self, msg, resp);
            }

            implement preaccept_reply_msg_t.handle(self: node_id, msg: preaccept_reply_msg_t) {
                debug "preaccept_reply_msg_t.handle" with msg=msg;

                if msg.ok {
                    # Merge all dependencies
                    for it, d in msg.deps {
                        deps(self).insert(d);
                    }

                    slowpath_accepts(self) := slowpath_accepts(self).add(msg.src);
                    if msg.witnessed_at = msg.first_proposed_at {
                        fastpath_accepts(self) := fastpath_accepts(self).add(msg.src);
                    }

                    if fastpath_accepts(self).majority(fd.my_electorate(self)) {
                        var resp: commit_msg_t;
                        resp.src := self;
                        resp.txn := msg.txn;
                        resp.execute_at := msg.first_proposed_at;
                        replica_multicast(self, resp);
                    } else if slowpath_accepts(self).majority(nset.fullset) {
                        var resp: accept_msg_t;
                        resp.src := self;
                        resp.txn := msg.txn;
                        #resp.execute_at := msg.witnessed_at;
                        replica_multicast(self, resp);
                    }
                }
            }

            implement commit_msg_t.handle(self: node_id, msg: commit_msg_t) {
                debug "commit_msg_t.handle" with msg=msg;
                protocol.handle_committed(self, msg);
            }

            implement accept_msg_t.handle(self: node_id, msg: accept_msg_t) {
                debug "accept_msg_t.handle" with msg=msg;
                assert false;
            }

            # Network helpers (c/o Ken's HW6 starter)

            implement sock.recv(self: node_id, src:tcp.endpoint, msg:msg_t) {
                msg.handle(self);
            }

            action unicast(self: node_id, outgoing : msg_t, dst_id : node_id) = {
                debug "send" with server = self, msg = outgoing, dst = dst_id;
                sock.send(self, coordinator(dst_id).sock.id,outgoing);
            }

            # TODO: right now, ignore replication for the moment.
            action replica_multicast(self: node_id, outgoing: msg_t) = {
                unicast(self, outgoing, self);
            }

            # node i broadcasts to nodes [i, i+elmax) % node.max
            action electorate_multicast(self: node_id, outgoing: msg_t) = {
                var it := node_it.begin();
                var e := node_it.end();
                while it ~= e {
                    # boy I hate this
                    if nset.member(it.value(), fd.my_electorate(self)) {
                        unicast(self, outgoing, it.value());
                    }
                    it := it.next();
                }
            }

            action broadcast(self: node_id, outgoing: msg_t) = {
                var it := node_it.begin();
                var e := node_it.end();
                while it ~= e {
                    unicast(self, outgoing, it.value());
                    it := it.next();
                }
            }
        }

        specification {
            # does N have a request in flight?
            relation req_in_flight(N: node_id)

            after init {
                req_in_flight(N) := false;
            }

            #before read(self: node_id, keys: vector[key]) {
                # TODO: how do I make the environment enforce that they give
                # me a non-empty keyset?  I've done this before with a
                # precondition, I thought...
                #                require keys.end > 0;
                #}
        }
    }
}

