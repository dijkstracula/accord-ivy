#lang ivy1.8

# Some functionality for logical timestamp operations.

include collections
include order
include types

global {
    instance walltime : unbounded_sequence
    instance sequence : unbounded_sequence

    class timestamp = {
        # TODO: epoch???  Probably not necessary for us.
        field real : walltime
        field seqid: sequence
    }

    function (LHS: timestamp < RHS: timestamp) =
        LHS.real < RHS.real |
        LHS.real = RHS.real & LHS.seqid < RHS.seqid 

    function (LHS: timestamp = RHS: timestamp) =
        LHS.real = RHS.real & 
        LHS.seqid = RHS.seqid
    
    function ts_lt(LHS: timestamp, RHS: timestamp) = LHS < RHS
}

module time(self: node) = {

    implementation {
        var curr_time   : walltime
        var last_issued : timestamp

        after init {
            curr_time := 1;
            last_issued.real := 0;
            last_issued.seqid := 0;

            prev_issued := last_issued; #ghost
        }

        # Advance time on occasion.
        action tick
        implement tick {
            curr_time := curr_time.next;
        }

        # Get "the current time".
        #export action now returns (ret : timestamp)
        action now returns (ret : timestamp)
        implement now {
            #TODO: I suspect we probably do not want to actually tick 
            #on every now() call, to ensure we sometimes get nonzero
            #seq ids.
            tick();

            #TODO: We need a mechanism to mutate curr_time when we 
            #receive a timestamp from the outside world.  Else, we will
            #never see the walltime go backwards.

            if last_issued.real >= curr_time {
                ret.real := last_issued.real;
                ret.seqid := last_issued.seqid.next;
            } else {
                ret.real := curr_time;
                ret.seqid := 0;
            }

            prev_issued := last_issued; #ghost
            last_issued := ret;
        }

        #TODO: How to put an upper bound?
        #invariant [ts_lt_nonreflexivity] ts_lt(TS,TS) = false
    } 

    specification {
        var prev_issued : timestamp
        after now {
            # Our clock must always move forward, no matter how coarse the real
            # clock is.
            ensure prev_issued < last_issued;
        }
    }
}

#axiom host(0).sock.id ~= host(1).sock.id
