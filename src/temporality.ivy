#lang ivy1.8

# Some functionality for logical timestamp operations.

include collections
include order
include types

global {
    instance walltime : unbounded_sequence
    instance sequence : unbounded_sequence

    class timestamp = {
        # TODO: epoch???  Probably not necessary for us.
        field real : walltime
        field seqid: sequence
    }

    function (LHS: timestamp < RHS: timestamp) =
        LHS.real < RHS.real |
        LHS.real = RHS.real & LHS.seqid < RHS.seqid 

    function (LHS: timestamp = RHS: timestamp) =
        LHS.real = RHS.real & 
        LHS.seqid = RHS.seqid
    
    function ts_lt(LHS: timestamp, RHS: timestamp) = LHS < RHS

    action next(self: timestamp) returns (ret: timestamp) = {
        ret.real  := self.real;
        ret.seqid := self.seqid.next();
    }

    action max(self: timestamp, other: timestamp) returns (ret: timestamp) = {
        if self < other {
            ret.real  := self.real;
            ret.seqid := self.seqid;
        } else {
            ret.real  := other.real;
            ret.seqid := other.seqid;
        }
    }
}

module time(self: node) = {

    implementation {
        # Our implementation of gettimeofday()
        var curr_time       : walltime

        # The latest timestamp we have either computed locally or
        # been sent by another node.
        var latest_observed : timestamp

        after init {
            curr_time := 1;
            latest_observed.real := 0;
            latest_observed.seqid := 0;

            prev_issued := latest_observed; #ghost
        }

        # Advance time on occasion.
        action tick
        implement tick {
            curr_time := curr_time.next;
        }

        # Get "the current time".
        action now returns (ret: timestamp)
        implement now {
            #TODO: I suspect we probably do not want to actually tick 
            #on every now() call, to ensure we sometimes get nonzero
            #seq ids (which is required for Theorem B.2.1.2).
            tick();

            #TODO: We need a mechanism to mutate curr_time when we 
            #receive a timestamp from the outside world.  Else, we will
            #never see the walltime go backwards.

            if latest_observed.real >= curr_time {
                ret.real := latest_observed.real;
                ret.seqid := latest_observed.seqid.next;
            } else {
                ret.real := curr_time;
                ret.seqid := 0;
            }

            prev_issued := latest_observed; #ghost
            latest_observed := ret;
        }

        action merge(remote_ts: timestamp)
        implement merge {
            if latest_observed < remote_ts {
                prev_issued := latest_observed; #ghost
                latest_observed := remote_ts;
            }
        }
    } 

    # Our clock must always move forward, no matter how coarse the real clock
    # is.
    invariant [clock_monotonicity] prev_issued <= latest_observed

    specification {
        var prev_issued : timestamp
    }
}

#axiom host(0).sock.id ~= host(1).sock.id
